<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Kray's Portfolio</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Cabin:700' rel='stylesheet' type='text/css'>

    <!-- Custom styles for this template -->
    <link href="css/grayscale.css" rel="stylesheet">
  </head>

  <body id="page-top">

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
      <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="index.html">Home</a>
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          Menu
          <i class="fa fa-bars"></i>
        </button>
      </div>
    </nav>

    <!-- About Section -->
    <section id="about" class="content-section text-center">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 mx-auto">
            <h2>City of Grand Rapids Cemeteries</h2>
				<p class="portf-text">The purpose of <a href="http://grandrapids.maps.arcgis.com/apps/webappviewer/index.html?id=53514aa28a584dbd8f07e7a3ced8af17">this project</a>
				was to allow any citizen to view cemeteries online so that they can search for occupants in any of Grand Rapids’ six cemeteries. 
				This project was based on four phases: implementing surveying maps, reconciling polygon data with cemetery records, automating much of the workflow in Python,
				and visualizing it all in ArcGIS Online.</p>
				<img src='img/cem_survey.png' style="width:100%"/>
				<p><em>Survey Map of Woodlawn West</em></p>
				<p class="portf-text">The first phase of the project dealt largely with georeferencing the surveying maps, converting the image to editable features,
				and cleaning up said features. Though there are six cemeteries, there were eight different maps, each of which being georeferenced to their respective cemetery.
				After georeferencing, the survey maps were converted into editable features via the <strong>Raster to Polygon</strong> tool. 
				From there, over 20,000 polygons from eight maps were cleaned up and labeled (e.g. deleting the numbers that were turned into polygons, 
				inserting “blocks” and “lots” metadata into each polygon).</p>
				<p class="portf-text">The second phase consisted of reconciling the polygons, which contained the bare metadata of “cemetery”, “block”, and “lot”, 
				with the richer data of a spreadsheet derived from the city’s cemetery database. This proved to somewhat of a challenge given that there were multiple
				occupants per lot, for the survey's smallest unit was not a <strong>grave</strong> but a <strong>lot</strong>. 
				With multiple occupants per lot, there were only two options:
				a many-to-one <strong>relate</strong> or building a query table in order to do a many-to-one <strong>join</strong>. I chose the latter. 
				While relating the information would be easiest and is possible in ArcGIS Online, the service’s online search function did not support data from relates, therefore,
				I had to build a query table.</p>
				<p class="portf-text">It should be noted that there are some inherent flaws when working with surveying maps from the mid to late 1900s. 
				Some data that existed in the up-to-date cemetery database was not reflected in the surveying maps, therefore,
				some lots — and subsequently occupants — do not appear in the final project. 
				Moreover, if  certain lots appeared in the surveying maps but did not appear in the spreadsheet, the query table operation then deleted empty polygons. 
				Interestingly, even though the map appears to have fewer polygons, there are actually more: in a many-to-one query table join, 
				polygons are stacked on top of each other when sharing the same space.</p>
				<img src='img/cem_arcmap1.png' style="width:100%"/>
				<p><em>Before Query Table Join</em></p>
				<img src='img/cem_arcmap2.png' style="width:100%"/>
				<p><em>After Query Table Join</em></p>
				<p class="portf-text" style="padding-bottom: 0em">For the third phase, I automated most of the workflow with Python. At a high level, the program:
					<ol style="text-align: left"> 
						<li>Creates a one-to-many join via a query table with the cemetery spreadsheet and the cemetery shapefile</li>
						<li>Splits the query table result into eight different shapefiles (if we use only one shapefile for the web application, 
						it would have to search through approximately 100,000 features - the maximum amount it can handle is around 20,000 features)</li>
						<li>Uploads the shapefiles to ArcGIS Online</li>
						<li>Creates Tile Layers from the shapefiles in ArcGIS Online (the Tile Layers help visualize the data more easily in the web applications)</li>
					</ol>
				</p>
				<p class="portf-text"><strong>Note:</strong> the file paths were removed from the following code.</p>
				<p class="portf-text">First, I create the query table from the shapefile and the spreadsheet and export the query table as its own shapefile name
				<strong>queryTable</strong>. </p>
				<ul><pre class="prettyprint portf-text">
 # create Query table 
 arcpy.TableToTable_conversion('occupants.csv', 'Cemeteries.gdb','occupants')

 table1 = 'cemetery_master'
 table2 = 'occupants'
 lyrName = 'queryOut'
 query = 'cemetery_master.CEM_ID = occupants.Plot_ConcatenatedPlot'

 arcpy.MakeQueryTable_management ([table1,table2], lyrName, '','','', query)
 arcpy.CopyFeatures_management(lyrName, 'queryTable')
				</pre></ul>
				<p class="portf-text">Next, the query table needs to be split into eight different parts (the end result of this project is eight different web applications
				for their respective cemeteries).</p>
				<ul><pre class="prettyprint portf-text">
 cemeteries = ['select_fairplains','select_greenwood','select_oakgrove',
               'select_oakhill_north','select_oakhill_south',
               'select_woodlawn_east','select_woodlawn_west','select_fulton']

 for cem in cemeteries:
     name = cem.replace('select_','')
     arcpy.MakeFeatureLayer_management('queryTable', 'temp')
     select = arcpy.SelectLayerByLocation_management ('temp','INTERSECT',cem)
     try:
         os.makedirs(name) # create folder to places the shapefiles in
     except:
         pass
     arcpy.CopyFeatures_management (select, name + '//' + name)
     arcpy.Delete_management(cwd_gdb+'//temp') # delete temporary file
     shutil.make_archive(name,'zip',name) # zip folders for upload to ArcGIS Online
				</pre></ul>
				<p class="portf-text">The <strong>ArcPy</strong> library — used above — that comes with ArcGIS for Desktop is built on Python 2.7. 
				The <a href='https://developers.arcgis.com/python/'>ArcGIS API for Python</a> (which allows me to easily manipulate files in ArcGIS Online) 
				is built on Python 3.5 (and above). So, I started a new script for this different library. The end function should overwrite shapefiles and 
				create new tiles layers in ArcGIS Online.</p>
				<p class="portf-text">The following function searches for shapefiles, feature services, and map services (tile layers) that match the cemetery's name. 
				If there is a match, they will be deleted.</p>
				<ul><pre class="prettyprint portf-text">
 def agolUpload(cemeteries):
   item_type = ['Feature Service','Shapefile','Map Service']
   for cem in cemeteries:
       try:
           searches = [gis.content.search(cem, item_type = j)
                                          for j in item_type]
           for item in searches:
               item[0].delete()
       except:
           pass
				</pre></ul>
				<p class="portf-text">After the files are deleted, the program uploads new shapefiles and creates tile layers from them.</p>
				<ul><pre class="prettyprint portf-text">
 def agolUpload(cemeteries):
	-- snip --
        item_properties = {'title': cem,
                           'tags': 'cemetery',
                           'type': 'Shapefile'}
        cem_shp = gis.content.add(item_properties, data = cem + '.zip')
        cem_shp.publish()
        feature_search = gis.content.search(cem, item_type='Feature Service')
        feature_search[0].create_tile_service(cem, 4000.0, 1.0)
				</pre></ul>
				<p class="portf-text">Finally, the function is called and passed a list of shapefiles.</p>
				<ul><pre class="prettyprint portf-text">
 cem_items = ['fairplains_py','fulton_py','greenwood_py','oakgrove_py',
              'oakhill_north_py','oakhill_south_py','woodlawn_east_py',
              'woodlawn_west_py']
 agolUpload(cem_items)
				</pre></ul>
				<p class="portf-text">The fourth phase consists of making web maps and configuring web applications from the data that was uploaded.</p>
				<p class="portf-text">You can find the full list of the cemeteries on the <a href="https://www.grandrapidsmi.gov/Government/Departments/Parks-and-Recreation/Cemeteries">City of Grand Rapids Cemeteries page</a>
				under <strong>Genealogy Information</strong>, 
				and if you want to test out searching through one of the cemeteries, <a href="http://grandrapids.maps.arcgis.com/apps/webappviewer/index.html?id=53514aa28a584dbd8f07e7a3ced8af17">
				click here</a>.</p>
		  </div>
        </div>
      </div>
    </section>
    <!-- Footer -->
    <footer>
      <div class="container text-center">
        <p>Copyright &copy; Kray Freestone 2018
		<br> Website built using HTML, CSS, Bootstrap, and Google's Code Prettify</p>
      </div>
    </footer>
	
	<!-- code-prettify by Google -->
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
    
	<!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Custom scripts for this template -->
    <script src="js/grayscale.js"></script>

  </body>

</html>
